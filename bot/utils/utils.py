"""Module with assorted utility functions.
"""
import json
import random
import string
from bot.deckbox.deckbox import Deckbox
from bot.mongo.mongo_client import MongoClient

class Utils:

  @classmethod
  async def generate_random_id(
      cls,
      length: int = 8,
  ) -> str:
    """Creates a random ID from random numbers.

    Args:
      length: length of the ID (Defaults to 8)

    Returns:
      A string with the ID
    """
    characters = string.digits
    random_id = ''.join(random.choices(characters, k=length))
    return random_id

  @classmethod
  def generate_outgoing_message(
      cls,
      command: str,
      chat_id: str,
      message_text: str,
      message_thread_id: str | None = None,
      options: dict | None = None,
      bot_type: str = "telegram",
  ) -> bytes:
    """Generates a message to be sent to a queue.

    Args:
      command: a string with a command to send
      chat_id: id of the chat to send response to
      message_text: message that will be sent
      message_thread_id: ID of the thread in the group
      options: additional options to send
      bot_type: type of the bot, defaults to "telegram"
    Returns:
      A dict encoded into bytes
    """
    if not options:
      options = {}
    message = {
      "command": command,
      "chat_id": chat_id,
      "message_thread_id": message_thread_id,
      "text": message_text,
      "bot_type": bot_type,
      "options": options,
    }
    json_message = json.dumps(message)
    message_bytes = json_message.encode("UTF-8")
    return message_bytes

  @classmethod
  async def find_letter_index(
      cls,
      input_list: list[str],
      letter: str,
  ) -> int | None:
    """Performs a binary search on list of strings to find the first index
    where a word starts with a given letter.

    Args:
      input_list: ordered list of strings
      letter: the letter to look for
    Returns:
      An index of a first found word starting with a letter or None if not found
    """
    left, right = 0, len(input_list) - 1
    result = -1
    while left <= right:
        mid = (left + right) // 2
        if input_list[mid].startswith(letter):
            result = mid
            right = mid - 1
        elif input_list[mid] < letter:
            left = mid + 1
        else:
            right = mid - 1
    return result if result != -1 else None

  @classmethod
  async def construct_found_message(
      cls,
      found_object: dict,
      deckbox_names: dict,
  ) -> list[str]:
    """Creates a message displaying the cards found during using the dict
    that was created after the search.

    Args:
      found_object: a dict that was generated by backend.search_for_cards
      deckbox_names: a dict using deckbox_ids as keys and corresponding account
      names as values
    Returns:
      A list of message strings
    """
    messages = []
    result_message = ""
    deckbox_ids = found_object.keys()
    for deckbox_id in deckbox_ids:
      if found_object[deckbox_id]:
        deckbox_name = deckbox_names[deckbox_id]
        db_url = await Deckbox.create_deckbox_user_url(username=deckbox_name)
        deckbox_link = f"<a href='{db_url}'><b>{deckbox_name}</b></a>"
        deckbox_message = f"\nDeckbox: {deckbox_link}\n"
        user_data = await MongoClient.get_user_data(deckbox=deckbox_name)
        if user_data:
          telegram_name = user_data.get("telegram")
          discord_name = user_data.get("discord")
          if telegram_name:
            deckbox_message += f"Telegram: {telegram_name}\n"
          if discord_name:
            deckbox_message += f"Discord: {discord_name}\n"
          if not telegram_name and not discord_name:
            deckbox_message += "\n"
        found_cards = found_object[deckbox_id]
        for card in found_cards:
          (name, count) = card
          card_url = await Deckbox.create_deckbox_url(
              deckbox_id=deckbox_id,
              card_name=name,
          )
          card_message = f"<a href='{card_url}'>{name}</a>: {count}\n"
          deckbox_message += card_message
          if len(deckbox_message) > 1800:
            messages.append(deckbox_message)
            deckbox_message = ""
        result_message += deckbox_message
        if len(result_message) > 1800:
          messages.append(result_message)
          result_message = ""
    if result_message:
      messages.append(result_message)
    if not messages:
      messages = ["No cards were found in deckboxes :("]
    return messages

  @classmethod
  async def construct_found_store_message(
      cls,
      found_object: dict,
      store_name: str,
  ) -> list[str]:
    """Creates a message displaying the cards found during using the dict
    that was created after the store search.

    Args:
      found_object: a dict that was generated by search
      store_name: name of the store for the header
    Returns:
      A list of message strings
    """
    messages = []
    result_message = f"Found cards in {store_name}:\n"
    cards_list = found_object.keys()
    for card_name in cards_list:
      card_list = found_object.get(card_name)
      for card in card_list:
        price = card.get("price")
        card_url = card.get("url")
        count = card.get("count")
        card_text = (
            f"<a href='{card_url}'><b>{card_name}</b></a>: {count} ({price})\n"
        )
        result_message += card_text
        if len(result_message) > 1700:
          messages.append(result_message)
          result_message = ""
    if cards_list:
      messages.append(result_message)
    if not messages:
      messages = [f"No cards were found in {store_name} :("]
    return messages

  @classmethod
  async def construct_subscription_message(
      cls,
      found_object: dict,
      deckbox_name: str,
      deckbox_id: str,
  ) -> list[str]:
    """Creates a message displaying the cards found during deckbox re-caching.

    Args:
      found_object: a dict with found cards
      deckbox_name: a string with deckbox name
      deckbox_name: a string with deckbox ID
    Returns:
      A list of message strings
    """
    db_url = await Deckbox.create_deckbox_user_url(
        username=deckbox_name,
    )
    messages = []
    deckbox_link = f"<a href='{db_url}'><b>{deckbox_name}</b></a>"
    sub_message = f"{deckbox_link} added new cards from your wishlist!\n"
    user_data = await MongoClient.get_user_data(deckbox=deckbox_name)
    if user_data:
      telegram_name = user_data.get("telegram")
      discord_name = user_data.get("discord")
      if telegram_name:
        sub_message += f"Telegram: {telegram_name}\n"
      if discord_name:
        sub_message += f"Discord: {discord_name}\n"
    for card in found_object.keys():
      count = found_object.get(card)
      card_url = await Deckbox.create_deckbox_url(
          deckbox_id=deckbox_id,
          card_name=card,
      )
      card_message = f"<a href='{card_url}'>{card}</a>: {count}\n"
      sub_message += card_message
      if len(sub_message) > 1700:
        messages.append(sub_message)
        sub_message = ""
    messages.append(sub_message)
    return messages

  @classmethod
  async def split_list_into_chunks(
      cls,
      input_list: list,
      max_length: int,
  ) -> str:
    """Splits a list into a list of lists with maximum length.

    Args:
      input_list: a list to be split
      max_length: maximum length of resulting 
    Returns:
      A list of lists
    """
    if len(input_list) < max_length + 1:
      return input_list
    result = []
    while input_list:
      result.append(input_list[:max_length])
      input_list = input_list[max_length:]
    return result

  @classmethod
  async def construct_united_search_dict(
      cls,
      input_dicts: list[dict],
  ) -> dict:
    """Creates one dict from list of dicts created by backed.search_for_cards or
    wish_for cards.

    Args:
      input_dicts: a list of dicts with search results
    Returns:
      A dict with unified search results
    """
    merged_dict = {}
    for dictionary in input_dicts:
      for key, value_list in dictionary.items():
        if key in merged_dict:
          merged_dict[key].extend(value_list)
        else:
          merged_dict[key] = value_list.copy()
    return merged_dict

  @classmethod
  async def construct_united_mythic_cards_dict(
      cls,
      input_dicts: list[dict],
  ) -> dict:
    """Creates one dict from list of dicts created by mythiccard card parsing

    Args:
      input_dicts: a list of dicts with card results
    Returns:
      A dict with unified card results
    """
    merged_dict = {}
    for dictionary in input_dicts:
      for key, value_list in dictionary.items():
        if key in merged_dict:
          merged_dict[key].extend(value_list)
        else:
          merged_dict[key] = value_list
    return merged_dict
